#!/usr/bin/env bun
/**
 * worktree-status - Show all worktrees for a repo with their branches
 * Usage: worktree-status <repo-name>
 */

import { $ } from "bun";
import { existsSync } from "fs";
import { basename, join } from "path";
import { homedir } from "os";

const color = (s: string, c: string) => `${Bun.color(c, "ansi")}${s}\x1b[0m`;
const link = (text: string, url: string) => `\x1b]8;;${url}\x1b\\${text}\x1b]8;;\x1b\\`;

const SEARCH_PATHS = [
  join(homedir(), "github"),
  join(homedir(), "instacart"),
  join(homedir(), "ava"),
  homedir(),
];

async function findRepo(repoName: string): Promise<string | null> {
  for (const base of SEARCH_PATHS) {
    const repoPath = join(base, repoName);
    const gitDir = join(repoPath, ".git");
    if (existsSync(gitDir)) {
      return repoPath;
    }
  }

  try {
    const result = await $`fd -t d -H "^${repoName}$" ${homedir()} --max-depth 3`
      .quiet()
      .text();
    const firstMatch = result.trim().split("\n")[0];
    if (firstMatch && existsSync(firstMatch)) {
      return firstMatch;
    }
  } catch {}

  return null;
}

interface Worktree {
  path: string;
  head: string;
  branch: string;
}

async function parseWorktrees(repoPath: string): Promise<Worktree[]> {
  const output = await $`git -C ${repoPath} worktree list --porcelain`.quiet().text();
  const worktrees: Worktree[] = [];
  let current: Partial<Worktree> = {};

  for (const line of output.split("\n")) {
    if (line.startsWith("worktree ")) {
      current.path = line.slice(9);
    } else if (line.startsWith("HEAD ")) {
      current.head = line.slice(5, 12);
    } else if (line.startsWith("branch refs/heads/")) {
      current.branch = line.slice(18);
    } else if (line === "detached") {
      current.branch = "(detached)";
    } else if (line === "" && current.path) {
      worktrees.push(current as Worktree);
      current = {};
    }
  }

  if (current.path) {
    worktrees.push(current as Worktree);
  }

  return worktrees;
}

async function getWorktreeStatus(
  worktreePath: string
): Promise<{ hasChanges: boolean; ahead: number; behind: number }> {
  if (!existsSync(worktreePath)) {
    return { hasChanges: false, ahead: 0, behind: 0 };
  }

  let hasChanges = false;
  let ahead = 0;
  let behind = 0;

  try {
    const diffResult = await $`git -C ${worktreePath} diff --quiet`.quiet().nothrow();
    const diffCachedResult = await $`git -C ${worktreePath} diff --cached --quiet`.quiet().nothrow();
    hasChanges = diffResult.exitCode !== 0 || diffCachedResult.exitCode !== 0;
  } catch {}

  try {
    const aheadBehind = await $`git -C ${worktreePath} rev-list --left-right --count HEAD...@{upstream}`
      .quiet()
      .text();
    const [aheadStr, behindStr] = aheadBehind.trim().split(/\s+/);
    ahead = parseInt(aheadStr, 10) || 0;
    behind = parseInt(behindStr, 10) || 0;
  } catch {}

  return { hasChanges, ahead, behind };
}

interface ProcessInfo {
  pid: number;
  port: number;
}

async function getListeningProcesses(): Promise<Map<string, ProcessInfo[]>> {
  const result = new Map<string, ProcessInfo[]>();

  try {
    const lsofOutput = await $`lsof -iTCP -sTCP:LISTEN -P -n`.quiet().nothrow().text();
    const pidPorts = new Map<number, Set<number>>();

    for (const line of lsofOutput.split("\n").slice(1)) {
      const parts = line.split(/\s+/);
      if (parts.length < 10) continue;

      const command = parts[0].toLowerCase();
      const pid = parseInt(parts[1], 10);
      const name = parts[8]; // e.g., "[::1]:5175" or "127.0.0.1:3000"

      if (!["node", "bun"].includes(command)) continue;

      const portMatch = name.match(/:(\d+)$/);
      if (!portMatch) continue;

      const port = parseInt(portMatch[1], 10);
      if (!pidPorts.has(pid)) pidPorts.set(pid, new Set());
      pidPorts.get(pid)!.add(port);
    }

    // Get cwd for each unique pid
    for (const [pid, ports] of pidPorts) {
      try {
        const cwdOutput = await $`lsof -p ${pid} -a -d cwd -Fn`.quiet().nothrow().text();
        const cwdMatch = cwdOutput.match(/\nn(.+)/);
        if (cwdMatch) {
          const cwd = cwdMatch[1];
          if (!result.has(cwd)) result.set(cwd, []);
          for (const port of ports) {
            result.get(cwd)!.push({ pid, port });
          }
        }
      } catch {}
    }
  } catch {}

  return result;
}

function colorBranch(branch: string): string {
  if (branch === "main" || branch === "master") {
    return color(branch, "green");
  } else if (branch === "(detached)") {
    return color(branch, "yellow");
  }
  return color(branch, "cyan");
}

async function main() {
  const repoName = process.argv[2];

  if (!repoName) {
    console.log("Usage: worktree-status <repo-name>");
    console.log("Example: worktree-status isc-web");
    process.exit(1);
  }

  const repoPath = await findRepo(repoName);

  if (!repoPath) {
    console.log(`Could not find repo: ${repoName}`);
    process.exit(1);
  }

  try {
    await $`git -C ${repoPath} rev-parse --git-dir`.quiet();
  } catch {
    console.log(`Not a git repository: ${repoPath}`);
    process.exit(1);
  }

  const listeningProcesses = await getListeningProcesses();
  const worktrees = await parseWorktrees(repoPath);

  console.log();
  console.log(`  ${color(repoName, "white")}  ${color(repoPath, "gray")}`);
  console.log();

  for (const wt of worktrees) {
    const dirName = basename(wt.path);
    const gitStatus = await getWorktreeStatus(wt.path);

    // Build status string
    let status = "";
    if (gitStatus.hasChanges) status += color(" *", "yellow");
    if (gitStatus.ahead > 0) status += color(` ↑${gitStatus.ahead}`, "green");
    if (gitStatus.behind > 0) status += color(` ↓${gitStatus.behind}`, "red");

    // Build server links
    const processes = listeningProcesses.get(wt.path) || [];
    const ports = [...new Set(processes.map((p) => p.port))].sort((a, b) => a - b);
    const serverStr = ports
      .map((port) => link(color(`:${port}`, "magenta"), `http://localhost:${port}`))
      .join(" ");

    // Output line
    const branch = colorBranch(wt.branch);
    console.log(`  ${color(dirName, "white").padEnd(40)} ${branch}${status}${serverStr ? "  " + serverStr : ""}`);
  }

  console.log();
}

main();
